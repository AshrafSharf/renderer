var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Vector3D = require("awayjs-core/lib/geom/Vector3D");
var ParticlePropertiesMode = require("awayjs-renderergl/lib/animators/data/ParticlePropertiesMode");
var ParticleNodeBase = require("awayjs-renderergl/lib/animators/nodes/ParticleNodeBase");
var ParticleAccelerationState = require("awayjs-renderergl/lib/animators/states/ParticleAccelerationState");
/**
 * A particle animation node used to apply a constant acceleration vector to the motion of a particle.
 */
var ParticleAccelerationNode = (function (_super) {
    __extends(ParticleAccelerationNode, _super);
    /**
     * Creates a new <code>ParticleAccelerationNode</code>
     *
     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
     * @param    [optional] acceleration    Defines the default acceleration vector of the node, used when in global mode.
     */
    function ParticleAccelerationNode(mode /*uint*/, acceleration) {
        if (acceleration === void 0) { acceleration = null; }
        _super.call(this, "ParticleAcceleration", mode, 3);
        this._pStateClass = ParticleAccelerationState;
        this._acceleration = acceleration || new Vector3D();
    }
    /**
     * @inheritDoc
     */
    ParticleAccelerationNode.prototype.pGetAGALVertexCode = function (shaderObject, animationRegisterCache) {
        var accelerationValue = (this._pMode == ParticlePropertiesMode.GLOBAL) ? animationRegisterCache.getFreeVertexConstant() : animationRegisterCache.getFreeVertexAttribute();
        animationRegisterCache.setRegisterIndex(this, ParticleAccelerationState.ACCELERATION_INDEX, accelerationValue.index);
        var temp = animationRegisterCache.getFreeVertexVectorTemp();
        animationRegisterCache.addVertexTempUsages(temp, 1);
        var code = "mul " + temp + "," + animationRegisterCache.vertexTime + "," + accelerationValue + "\n";
        if (animationRegisterCache.needVelocity) {
            var temp2 = animationRegisterCache.getFreeVertexVectorTemp();
            code += "mul " + temp2 + "," + temp + "," + animationRegisterCache.vertexTwoConst + "\n";
            code += "add " + animationRegisterCache.velocityTarget + ".xyz," + temp2 + ".xyz," + animationRegisterCache.velocityTarget + ".xyz\n";
        }
        animationRegisterCache.removeVertexTempUsage(temp);
        code += "mul " + temp + "," + temp + "," + animationRegisterCache.vertexTime + "\n";
        code += "add " + animationRegisterCache.positionTarget + ".xyz," + temp + "," + animationRegisterCache.positionTarget + ".xyz\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleAccelerationNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticleAccelerationNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
        var tempAcceleration = param[ParticleAccelerationNode.ACCELERATION_VECTOR3D];
        if (!tempAcceleration)
            throw new Error("there is no " + ParticleAccelerationNode.ACCELERATION_VECTOR3D + " in param!");
        this._pOneData[0] = tempAcceleration.x / 2;
        this._pOneData[1] = tempAcceleration.y / 2;
        this._pOneData[2] = tempAcceleration.z / 2;
    };
    /**
     * Reference for acceleration node properties on a single particle (when in local property mode).
     * Expects a <code>Vector3D</code> object representing the direction of acceleration on the particle.
     */
    ParticleAccelerationNode.ACCELERATION_VECTOR3D = "AccelerationVector3D";
    return ParticleAccelerationNode;
})(ParticleNodeBase);
module.exports = ParticleAccelerationNode;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImF3YXlqcy1yZW5kZXJlcmdsL2xpYi9hbmltYXRvcnMvbm9kZXMvUGFydGljbGVBY2NlbGVyYXRpb25Ob2RlLnRzIl0sIm5hbWVzIjpbIlBhcnRpY2xlQWNjZWxlcmF0aW9uTm9kZSIsIlBhcnRpY2xlQWNjZWxlcmF0aW9uTm9kZS5jb25zdHJ1Y3RvciIsIlBhcnRpY2xlQWNjZWxlcmF0aW9uTm9kZS5wR2V0QUdBTFZlcnRleENvZGUiLCJQYXJ0aWNsZUFjY2VsZXJhdGlvbk5vZGUuZ2V0QW5pbWF0aW9uU3RhdGUiLCJQYXJ0aWNsZUFjY2VsZXJhdGlvbk5vZGUuX2lHZW5lcmF0ZVByb3BlcnR5T2ZPbmVQYXJ0aWNsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsSUFBTyxRQUFRLFdBQWlCLCtCQUErQixDQUFDLENBQUM7QUFRakUsSUFBTyxzQkFBc0IsV0FBYSw2REFBNkQsQ0FBQyxDQUFDO0FBQ3pHLElBQU8sZ0JBQWdCLFdBQWUsd0RBQXdELENBQUMsQ0FBQztBQUNoRyxJQUFPLHlCQUF5QixXQUFZLGtFQUFrRSxDQUFDLENBQUM7QUFFaEgsQUFHQTs7R0FERztJQUNHLHdCQUF3QjtJQUFTQSxVQUFqQ0Esd0JBQXdCQSxVQUF5QkE7SUFXdERBOzs7OztPQUtHQTtJQUNIQSxTQWpCS0Esd0JBQXdCQSxDQWlCakJBLElBQUlBLENBQVFBLFFBQURBLEFBQVNBLEVBQUVBLFlBQTRCQTtRQUE1QkMsNEJBQTRCQSxHQUE1QkEsbUJBQTRCQTtRQUU3REEsa0JBQU1BLHNCQUFzQkEsRUFBRUEsSUFBSUEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFFdkNBLElBQUlBLENBQUNBLFlBQVlBLEdBQUdBLHlCQUF5QkEsQ0FBQ0E7UUFFOUNBLElBQUlBLENBQUNBLGFBQWFBLEdBQUdBLFlBQVlBLElBQUlBLElBQUlBLFFBQVFBLEVBQUVBLENBQUNBO0lBQ3JEQSxDQUFDQTtJQUVERDs7T0FFR0E7SUFDSUEscURBQWtCQSxHQUF6QkEsVUFBMEJBLFlBQTZCQSxFQUFF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Q0FBQ0E7UUFDekNBLElBQUlBLENBQUNBLFNBQVNBLENBQUNBLENBQUNBLENBQUNBLEdBQUdBLGdCQUFnQkEsQ0FBQ0EsQ0FBQ0EsR0FBQ0EsQ0FBQ0EsQ0FBQ0E7SUFDMUNBLENBQUNBO0lBbEVESjs7O09BR0dBO0lBQ1dBLDhDQUFxQkEsR0FBVUEsc0JBQXNCQSxDQUFDQTtJQStEckVBLCtCQUFDQTtBQUFEQSxDQXhFQSxBQXdFQ0EsRUF4RXNDLGdCQUFnQixFQXdFdEQ7QUFFRCxBQUFrQyxpQkFBekIsd0JBQXdCLENBQUMiLCJmaWxlIjoiYW5pbWF0b3JzL25vZGVzL1BhcnRpY2xlQWNjZWxlcmF0aW9uTm9kZS5qcyIsInNvdXJjZVJvb3QiOiIuLi8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVmVjdG9yM0RcdFx0XHRcdFx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1jb3JlL2xpYi9nZW9tL1ZlY3RvcjNEXCIpO1xyXG5cclxuaW1wb3J0IEFuaW1hdG9yQmFzZVx0XHRcdFx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1yZW5kZXJlcmdsL2xpYi9hbmltYXRvcnMvQW5pbWF0b3JCYXNlXCIpO1xyXG5pbXBvcnQgQW5pbWF0aW9uUmVnaXN0ZXJDYWNoZVx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1yZW5kZXJlcmdsL2xpYi9hbmltYXRvcnMvZGF0YS9BbmltYXRpb25SZWdpc3RlckNhY2hlXCIpO1xyXG5pbXBvcnQgU2hhZGVyT2JqZWN0QmFzZVx0XHRcdFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtcmVuZGVyZXJnbC9saWIvY29tcGlsYXRpb24vU2hhZGVyT2JqZWN0QmFzZVwiKTtcclxuaW1wb3J0IFNoYWRlclJlZ2lzdGVyRWxlbWVudFx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1yZW5kZXJlcmdsL2xpYi9jb21waWxhdGlvbi9TaGFkZXJSZWdpc3RlckVsZW1lbnRcIik7XHJcblxyXG5pbXBvcnQgUGFydGljbGVQcm9wZXJ0aWVzXHRcdFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtcmVuZGVyZXJnbC9saWIvYW5pbWF0b3JzL2RhdGEvUGFydGljbGVQcm9wZXJ0aWVzXCIpO1xyXG5pbXBvcnQgUGFydGljbGVQcm9wZXJ0aWVzTW9kZVx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1yZW5kZXJlcmdsL2xpYi9hbmltYXRvcnMvZGF0YS9QYXJ0aWNsZVByb3BlcnRpZXNNb2RlXCIpO1xyXG5pbXBvcnQgUGFydGljbGVOb2RlQmFzZVx0XHRcdFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtcmVuZGVyZXJnbC9saWIvYW5pbWF0b3JzL25vZGVzL1BhcnRpY2xlTm9kZUJhc2VcIik7XHJcbmltcG9ydCBQYXJ0aWNsZUFjY2VsZXJhdGlvblN0YXRlXHRcdD0gcmVxdWlyZShcImF3YXlqcy1yZW5kZXJlcmdsL2xpYi9hbmltYXRvcnMvc3RhdGVzL1BhcnRpY2xlQWNjZWxlcmF0aW9uU3RhdGVcIik7XHJcblxyXG4vKipcclxuICogQSBwYXJ0aWNsZSBhbmltYXRpb24gbm9kZSB1c2VkIHRvIGFwcGx5IGEgY29uc3RhbnQgYWNjZWxlcmF0aW9uIHZlY3RvciB0byB0aGUgbW90aW9uIG9mIGEgcGFydGljbGUuXHJcbiAqL1xyXG5jbGFzcyBQYXJ0aWNsZUFjY2VsZXJhdGlvbk5vZGUgZXh0ZW5kcyBQYXJ0aWNsZU5vZGVCYXNlXHJcbntcclxuXHQvKiogQHByaXZhdGUgKi9cclxuXHRwdWJsaWMgX2FjY2VsZXJhdGlvbjpWZWN0b3IzRDtcclxuXHJcblx0LyoqXHJcblx0ICogUmVmZXJlbmNlIGZvciBhY2NlbGVyYXRpb24gbm9kZSBwcm9wZXJ0aWVzIG9uIGEgc2luZ2xlIHBhcnRpY2xlICh3aGVuIGluIGxvY2FsIHByb3BlcnR5IG1vZGUpLlxyXG5cdCAqIEV4cGVjdHMgYSA8Y29kZT5WZWN0b3IzRDwvY29kZT4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZGlyZWN0aW9uIG9mIGFjY2VsZXJhdGlvbiBvbiB0aGUgcGFydGljbGUuXHJcblx0ICovXHJcblx0cHVibGljIHN0YXRpYyBBQ0NFTEVSQVRJT05fVkVDVE9SM0Q6c3RyaW5nID0gXCJBY2NlbGVyYXRpb25WZWN0b3IzRFwiO1xyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IDxjb2RlPlBhcnRpY2xlQWNjZWxlcmF0aW9uTm9kZTwvY29kZT5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSAgICAgICAgICAgICAgIG1vZGUgICAgICAgICAgICBEZWZpbmVzIHdoZXRoZXIgdGhlIG1vZGUgb2Ygb3BlcmF0aW9uIGFjdHMgb24gbG9jYWwgcHJvcGVydGllcyBvZiBhIHBhcnRpY2xlIG9yIGdsb2JhbCBwcm9wZXJ0aWVzIG9mIHRoZSBub2RlLlxyXG5cdCAqIEBwYXJhbSAgICBbb3B0aW9uYWxdIGFjY2VsZXJhdGlvbiAgICBEZWZpbmVzIHRoZSBkZWZhdWx0IGFjY2VsZXJhdGlvbiB2ZWN0b3Igb2YgdGhlIG5vZGUsIHVzZWQgd2hlbiBpbiBnbG9iYWwgbW9kZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcihtb2RlOm51bWJlciAvKnVpbnQqLywgYWNjZWxlcmF0aW9uOlZlY3RvcjNEID0gbnVsbClcclxuXHR7XHJcblx0XHRzdXBlcihcIlBhcnRpY2xlQWNjZWxlcmF0aW9uXCIsIG1vZGUsIDMpO1xyXG5cclxuXHRcdHRoaXMuX3BTdGF0ZUNsYXNzID0gUGFydGljbGVBY2NlbGVyYXRpb25TdGF0ZTtcclxuXHJcblx0XHR0aGlzLl9hY2NlbGVyYXRpb24gPSBhY2NlbGVyYXRpb24gfHwgbmV3IFZlY3RvcjNEKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAaW5oZXJpdERvY1xyXG5cdCAqL1xyXG5cdHB1YmxpYyBwR2V0QUdBTFZlcnRleENvZGUoc2hhZGVyT2JqZWN0OlNoYWRlck9iamVjdEJhc2UsIGFuaW1hdGlvblJlZ2lzdGVyQ2FjaGU6QW5pbWF0aW9uUmVnaXN0ZXJDYWNoZSk6c3RyaW5nXHJcblx0e1xyXG5cdFx0dmFyIGFjY2VsZXJhdGlvblZhbHVlOlNoYWRlclJlZ2lzdGVyRWxlbWVudCA9ICh0aGlzLl9wTW9kZSA9PSBQYXJ0aWNsZVByb3BlcnRpZXNNb2RlLkdMT0JBTCk/IGFuaW1hdGlvblJlZ2lzdGVyQ2FjaGUuZ2V0RnJlZVZlcnRleENvbnN0YW50KCkgOiBhbmltYXRpb25SZWdpc3RlckNhY2hlLmdldEZyZWVWZXJ0ZXhBdHRyaWJ1dGUoKTtcclxuXHRcdGFuaW1hdGlvblJlZ2lzdGVyQ2FjaGUuc2V0UmVnaXN0ZXJJbmRleCh0aGlzLCBQYXJ0aWNsZUFjY2VsZXJhdGlvblN0YXRlLkFDQ0VMRVJBVElPTl9JTkRFWCwgYWNjZWxlcmF0aW9uVmFsdWUuaW5kZXgpO1xyXG5cclxuXHRcdHZhciB0ZW1wOlNoYWRlclJlZ2lzdGVyRWxlbWVudCA9IGFuaW1hdGlvblJlZ2lzdGVyQ2FjaGUuZ2V0RnJlZVZlcnRleFZlY3RvclRlbXAoKTtcclxuXHRcdGFuaW1hdGlvblJlZ2lzdGVyQ2FjaGUuYWRkVmVydGV4VGVtcFVzYWdlcyh0ZW1wLCAxKTtcclxuXHJcblx0XHR2YXIgY29kZTpzdHJpbmcgPSBcIm11bCBcIiArIHRlbXAgKyBcIixcIiArIGFuaW1hdGlvblJlZ2lzdGVyQ2FjaGUudmVydGV4VGltZSArIFwiLFwiICsgYWNjZWxlcmF0aW9uVmFsdWUgKyBcIlxcblwiO1xyXG5cclxuXHRcdGlmIChhbmltYXRpb25SZWdpc3RlckNhY2hlLm5lZWRWZWxvY2l0eSkge1xyXG5cdFx0XHR2YXIgdGVtcDI6U2hhZGVyUmVnaXN0ZXJFbGVtZW50ID0gYW5pbWF0aW9uUmVnaXN0ZXJDYWNoZS5nZXRGcmVlVmVydGV4VmVjdG9yVGVtcCgpO1xyXG5cdFx0XHRjb2RlICs9IFwibXVsIFwiICsgdGVtcDIgKyBcIixcIiArIHRlbXAgKyBcIixcIiArIGFuaW1hdGlvblJlZ2lzdGVyQ2FjaGUudmVydGV4VHdvQ29uc3QgKyBcIlxcblwiO1xyXG5cdFx0XHRjb2RlICs9IFwiYWRkIFwiICsgYW5pbWF0aW9uUmVnaXN0ZXJDYWNoZS52ZWxvY2l0eVRhcmdldCArIFwiLnh5eixcIiArIHRlbXAyICsgXCIueHl6LFwiICsgYW5pbWF0aW9uUmVnaXN0ZXJDYWNoZS52ZWxvY2l0eVRhcmdldCArIFwiLnh5elxcblwiO1xyXG5cdFx0fVxyXG5cdFx0YW5pbWF0aW9uUmVnaXN0ZXJDYWNoZS5yZW1vdmVWZXJ0ZXhUZW1wVXNhZ2UodGVtcCk7XHJcblxyXG5cdFx0Y29kZSArPSBcIm11bCBcIiArIHRlbXAgKyBcIixcIiArIHRlbXAgKyBcIixcIiArIGFuaW1hdGlvblJlZ2lzdGVyQ2FjaGUudmVydGV4VGltZSArIFwiXFxuXCI7XHJcblx0XHRjb2RlICs9IFwiYWRkIFwiICsgYW5pbWF0aW9uUmVnaXN0ZXJDYWNoZS5wb3NpdGlvblRhcmdldCArIFwiLnh5eixcIiArIHRlbXAgKyBcIixcIiArIGFuaW1hdGlvblJlZ2lzdGVyQ2FjaGUucG9zaXRpb25UYXJnZXQgKyBcIi54eXpcXG5cIjtcclxuXHRcdHJldHVybiBjb2RlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQGluaGVyaXREb2NcclxuXHQgKi9cclxuXHRwdWJsaWMgZ2V0QW5pbWF0aW9uU3RhdGUoYW5pbWF0b3I6QW5pbWF0b3JCYXNlKTpQYXJ0aWNsZUFjY2VsZXJhdGlvblN0YXRlXHJcblx0e1xyXG5cdFx0cmV0dXJuIDxQYXJ0aWNsZUFjY2VsZXJhdGlvblN0YXRlPiBhbmltYXRvci5nZXRBbmltYXRpb25TdGF0ZSh0aGlzKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBpbmhlcml0RG9jXHJcblx0ICovXHJcblx0cHVibGljIF9pR2VuZXJhdGVQcm9wZXJ0eU9mT25lUGFydGljbGUocGFyYW06UGFydGljbGVQcm9wZXJ0aWVzKVxyXG5cdHtcclxuXHRcdHZhciB0ZW1wQWNjZWxlcmF0aW9uOlZlY3RvcjNEID0gcGFyYW1bUGFydGljbGVBY2NlbGVyYXRpb25Ob2RlLkFDQ0VMRVJBVElPTl9WRUNUT1IzRF07XHJcblx0XHRpZiAoIXRlbXBBY2NlbGVyYXRpb24pXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInRoZXJlIGlzIG5vIFwiICsgUGFydGljbGVBY2NlbGVyYXRpb25Ob2RlLkFDQ0VMRVJBVElPTl9WRUNUT1IzRCArIFwiIGluIHBhcmFtIVwiKTtcclxuXHJcblx0XHR0aGlzLl9wT25lRGF0YVswXSA9IHRlbXBBY2NlbGVyYXRpb24ueC8yO1xyXG5cdFx0dGhpcy5fcE9uZURhdGFbMV0gPSB0ZW1wQWNjZWxlcmF0aW9uLnkvMjtcclxuXHRcdHRoaXMuX3BPbmVEYXRhWzJdID0gdGVtcEFjY2VsZXJhdGlvbi56LzI7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgPSBQYXJ0aWNsZUFjY2VsZXJhdGlvbk5vZGU7Il19