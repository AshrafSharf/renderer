///<reference path="../_definitions.ts"/>

module away.primitives
{
	//import away3d.arcane;
	//import away3d.core.base.CompactSubGeometry;
	//import away3d.core.base.Geometry;
	//import away3d.core.base.ISubGeometry;
	//import away3d.errors.AbstractMethodError;
	
	//import flash.geom.Matrix3D;
	
	//use namespace arcane;
	
	/**
	 * PrimitiveBase is an abstract base class for mesh primitives, which are prebuilt simple meshes.
	 */
	export class PrimitiveBase extends away.base.Geometry
	{
		private _geomDirty:boolean = true;
		private _uvDirty:boolean = true;
		
		private _subGeometry:away.base.CompactSubGeometry;
		
		/**
		 * Creates a new PrimitiveBase object.
		 * @param material The material with which to render the object
		 */
		constructor()
		{
            super();

			this._subGeometry = new away.base.CompactSubGeometry();
			this._subGeometry.autoGenerateDummyUVs = false;
			this.addSubGeometry( this._subGeometry );
		}
		
		/**
		 * @inheritDoc
		 */
		public get subGeometries():away.base.ISubGeometry[]
		{
			if (this._geomDirty)
            {

                this.updateGeometry();

            }

			if ( this._uvDirty )
            {

                this.updateUVs();
            }

			
			return super.getSubGeometries();
		}
		
		/**
		 * @inheritDoc
		 */
		public clone():away.base.Geometry
		{
			if (this._geomDirty)
            {

                this.updateGeometry();

            }

			if ( this._uvDirty )
            {
                this.updateUVs();
            }

			
			return super.clone();
		}
		
		/**
		 * @inheritDoc
		 */
		public scale(scale:number)
		{
			if ( this._geomDirty)
            {
                this.updateGeometry();
            }

			
			super.scale(scale);
		}
		
		/**
		 * @inheritDoc
		 */
		public scaleUV(scaleU:number = 1, scaleV:number = 1)
		{
			if (this._uvDirty)
            {

                this.updateUVs();

            }

			
			super.scaleUV(scaleU, scaleV);
		}
		
		/**
		 * @inheritDoc
		 */
		public applyTransformation(transform:away.geom.Matrix3D)
		{
			if (this._geomDirty)
            {

                this.updateGeometry();

            }

			super.applyTransformation(transform);

		}
		
		/**
		 * Builds the primitive's geometry when invalid. This method should not be called directly. The calling should
		 * be triggered by the invalidateGeometry method (and in turn by updateGeometry).
		 */
		public pBuildGeometry(target:away.base.CompactSubGeometry)
		{
			throw new away.errors.AbstractMethodError();
		}
		
		/**
		 * Builds the primitive's uv coordinates when invalid. This method should not be called directly. The calling
		 * should be triggered by the invalidateUVs method (and in turn by updateUVs).
		 */
		public pBuildUVs(target:away.base.CompactSubGeometry)
		{
			throw new away.errors.AbstractMethodError();
		}
		
		/**
		 * Invalidates the primitive's geometry, causing it to be updated when requested.
		 */
		public pIvalidateGeometry()
		{
			this._geomDirty = true;
		}
		
		/**
		 * Invalidates the primitive's uv coordinates, causing them to be updated when requested.
		 */
		public pInvalidateUVs()
		{
			this._uvDirty = true;
		}
		
		/**
		 * Updates the geometry when invalid.
		 */
		private updateGeometry()
		{
			this.pBuildGeometry(this._subGeometry);
			this._geomDirty = false;
		}
		
		/**
		 * Updates the uv coordinates when invalid.
		 */
		private updateUVs()
		{
			this.pBuildUVs(this._subGeometry);
			this._uvDirty = false;
		}
		
		public iValidate()
		{
			if (this._geomDirty)
            {

                this.updateGeometry();

            }

			if (this._uvDirty)
            {

                this.updateUVs();

            }

		}
	}
}
